# Architecture Constitution v4.0

**Version**: 4.0.0
**Date**: 2025-11-18
**Status**: Production Architecture - Multi-Agent Orchestrator
**Breaking Changes**: Yes - Pivot from RAG Q&A to Multi-Agent Coder + Web Agent System

---

## Preamble

This constitution defines the architectural principles for a **Multi-Agent Orchestrator** system that enables intelligent automation of coding tasks and web tasks through cost-optimized LLM routing. The system supports two specialized agents:

1. **Coder Agent**: Interacts with codebases (read, modify, commit)
2. **Web Agent**: Interacts with websites (scrape, automate, research)

Both agents use the same 5-tier cost optimization framework while specializing in their respective domains.

---

## Core Principles

### I. Visual-First Design

**Requirement**: All multi-agent workflows MUST be representable in n8n's visual interface.

**Rationale**: Visual workflows enable non-programmers to understand, debug, and modify agent behavior. Agent logic should be transparent, not hidden in code.

**Requirements**:
- ALL agent orchestration logic MUST be expressed as n8n workflows
- ALL branching decisions (agent selection, tier routing) MUST use n8n IF nodes
- ALL loops (task execution, file processing) MUST use n8n Loop nodes
- Custom code MUST be limited to n8n Code nodes (JavaScript only, < 50 lines per node)
- No external Python/Node.js services for core agent logic

**Agent-Specific**:
- **Coder Agent**: File read/write operations via n8n File nodes or Code nodes
- **Web Agent**: Browser automation via HTTP calls to Playwright service (n8n HTTP Request nodes)

**Implementation**:
- Master Orchestrator: n8n workflow with agent selection logic
- Coder Agent: n8n workflow with file I/O and git operations
- Web Agent: n8n workflow with Playwright HTTP calls

**Validation**:
- âœ… Can I export the entire agent logic as n8n JSON?
- âœ… Can I visualize the agent flow in n8n GUI?
- âœ… Can I test each node independently in n8n test mode?

---

### II. Open-Source First & LLM-Agnostic Architecture

**Requirement**: Prioritize open-source LLMs on VPS/local infrastructure. Use premium APIs ONLY as architects/advisors, never as primary executors.

**Rationale**:
- **Cost Control**: Premium API usage ($3-15/M tokens) is expensive. Open-source on VPS ($75/month fixed) is predictable.
- **Privacy**: Local models keep sensitive data on-premises. Critical for private mode.
- **Sustainability**: Premium subscriptions are affordable, but API costs scale dangerously. Open-source execution prevents runaway costs.
- **Future-proof**: Local models can eventually run on home hardware. Premium trillion-parameter models cannot.

**Core Strategy**:
1. **Tier 0/1 as Primary Workers**: 80%+ of execution happens on open-source models
2. **Tier 3 as Architects Only**: Premium models plan/review, NOT execute
3. **Architect â†’ Executor Pattern**: Tier 3 creates plan, Tier 0/1 executes steps
4. **Privacy Mode**: Option to exclude ALL external APIs (premium + API-based tiers)

**Requirements**:
- ALL LLM calls MUST go through unified interface layer (**LiteLLM**, not direct API calls)
- Provider switching MUST NOT require workflow redesign
- **Open-source leverage**: Target 80%+ of LLM calls to Tier 0/1 (open-source)
- **Premium as advisors**: Tier 3 usage MUST be limited to planning, review, complex reasoning
- **Modality detection**: Automatically select vision-capable models for screenshot analysis tasks
- **Provider aliasing**: Use model groups (architect, executor, vision) not specific models

**Agent-Specific**:
- **Coder Agent**: Text-only models sufficient (Tier 0/1/3)
- **Web Agent**: May need vision models (Tier 2) for screenshot analysis

**LiteLLM Configuration**:
```yaml
model_list:
  - model_name: fast_filter    # Tier 0: Classification, intent detection
    litellm_params:
      model: ollama/llama3.2:3b

  - model_name: executor       # Tier 1: Code generation, web parsing
    litellm_params:
      model: fireworks_ai/llama-v3p1-8b-instruct

  - model_name: vision         # Tier 2: Screenshot analysis
    litellm_params:
      model: ollama/llama3.2-vision:70b

  - model_name: architect      # Tier 3: Planning, review
    litellm_params:
      model: claude-3-5-sonnet-20241022

  - model_name: batch_gpu      # Tier 4: Batch codebase indexing
    litellm_params:
      model: openai/meta-llama/llama-3.1-405b-instruct
      api_base: ${RUNPOD_ENDPOINT}
```

**Validation**:
- âœ… Can I switch from Claude to Gemini by changing 1 line in config?
- âœ… Does system auto-detect screenshots and route to vision model?
- âœ… Are all providers accessed through LiteLLM (no direct API calls)?

---

### III. Fail-Safe Operations (NON-NEGOTIABLE)

**Requirement**: System MUST handle errors gracefully and never leave codebases or web sessions in broken states.

**Rationale**: Agent modifications to code or web interactions can have destructive side effects. System must be production-safe.

**Requirements**:
- **ALL** LLM calls MUST have timeout (30s)
- **ALL** LLM calls MUST have retry with exponential backoff (max 3 retries)
- **ALL** file modifications MUST be git-tracked (automatic commits)
- **ALL** web browser sessions MUST have cleanup handlers (close browser on error)
- **ALL** errors MUST return user-friendly messages (not stack traces)

**Agent-Specific Safeguards**:

**Coder Agent**:
- **Before modifying code**: Create git branch `ai-agent/{task-id}`
- **After modifications**: Automatic git commit with detailed message
- **On error**: Revert changes via `git reset --hard HEAD`
- **File operations**: Validate file exists before read, check permissions before write
- **Syntax validation**: Run linter/formatter after code generation (optional)

**Web Agent**:
- **Browser sessions**: Always run in headless mode with timeout
- **On error**: Screenshot saved to debug folder, browser closed
- **Authentication**: Never log credentials, use environment variables
- **Rate limiting**: Respect robots.txt, add delays between requests
- **Cleanup**: Always close browser on workflow end (try/finally pattern)

**Implementation**:
```javascript
// n8n Error Handling Pattern
try {
  // Execute agent task
  const result = await executeTask();

  // Git commit for Coder Agent
  if (agent === 'coder') {
    await gitCommit(result.modifiedFiles);
  }

  // Cleanup for Web Agent
  if (agent === 'web') {
    await closeBrowser();
  }

  return result;
} catch (error) {
  // Rollback for Coder Agent
  if (agent === 'coder') {
    await gitReset();
  }

  // Screenshot + cleanup for Web Agent
  if (agent === 'web') {
    await saveScreenshot(error.context);
    await closeBrowser();
  }

  // Return user-friendly error
  return {
    status: 'error',
    message: 'Task failed: ' + error.userMessage,
    details: error.debugInfo
  };
}
```

**Validation**:
- âœ… Does Coder Agent create git commit after every modification?
- âœ… Does Coder Agent revert on error?
- âœ… Does Web Agent close browser on error?
- âœ… Are all errors logged with full context?

---

### IV. Cost-Conscious Design

**Requirement**: Monitor token usage, cache responses, optimize prompts, **implement mandatory pre-budget checks**.

**Rationale**: Multi-agent workflows can quickly exhaust budgets through repeated LLM calls. Cost control is critical for production use.

**Requirements**:
- **PRE-BUDGET CHECK** (MANDATORY): Every LLM call MUST validate budget before execution
- **Token tracking**: Every LLM response MUST log token usage and cost
- **Caching**: Identical queries MUST be cached (Helicone 1-hour TTL)
- **Prompt optimization**: Long contexts MUST be compressed via Tier 0 before Tier 3
- **Batch detection**: High-volume tasks (>50 operations) MUST route to Tier 4 GPU rental

**Agent-Specific Optimization**:

**Coder Agent**:
- **Code retrieval**: Use RAG to retrieve only relevant files (not entire codebase)
- **Incremental processing**: Process one file at a time, not all files in batch
- **Architect/Executor pattern**: Plan with Tier 3, execute with Tier 0/1
- **Code context compression**: Send only function signatures, not full implementations

**Web Agent**:
- **Content extraction**: Use Firecrawl for structured extraction (cheaper than vision)
- **Vision fallback**: Only use Tier 2 vision when Firecrawl fails
- **Caching**: Cache web page content for 1 hour (avoid re-scraping)
- **Batch scraping**: If scraping >50 pages, route to Tier 4

**Pre-Budget Check Flow**:
```javascript
// MANDATORY before every LLM call
function preBudgetCheck(tier, estimatedTokens) {
  const pool = getTierBudgetPool(tier);
  const estimatedCost = calculateCost(tier, estimatedTokens);
  const currentBalance = getBudgetBalance(pool);

  if (currentBalance < estimatedCost) {
    // BLOCK the call
    throw new BudgetExhaustedError({
      pool: pool,
      balance: currentBalance,
      required: estimatedCost,
      message: 'Insufficient budget. Task blocked.'
    });
  }

  // Reserve budget (optimistic lock)
  reserveBudget(pool, estimatedCost);

  return {
    approved: true,
    pool: pool,
    estimatedCost: estimatedCost,
    balanceAfter: currentBalance - estimatedCost
  };
}
```

**Budget Pool Allocation**:
- Hourly VRAM (Tier 4): $100/month
- Per-Token (Tier 1): $50/month
- Premium (Tier 3): $50/month (increased from $30 due to more planning needed)
- Local VPS (Tier 0/2): $75/month

**Validation**:
- âœ… Does every LLM call run pre-budget check?
- âœ… Are all costs logged per agent task?
- âœ… Does system block calls when budget exhausted?
- âœ… Is prompt compression active for contexts >10k tokens?

---

### V. Observable Agent Flows

**Requirement**: Structured logging, prompt/response capture, metrics tracking, **cost analytics per agent**.

**Rationale**: Multi-agent systems are complex. Full observability is essential for debugging, cost optimization, and quality improvement.

**Requirements**:
- **ALL** workflow executions MUST log: start time, end time, status, agent type
- **ALL** LLM calls MUST log: prompt, response, tier used, cost, tokens
- **ALL** file modifications MUST log: file path, changes made, git commit hash
- **ALL** web interactions MUST log: URL, action, screenshot path, response time
- **Distributed tracing**: OpenTelemetry spans for full request path
- **Cost analytics**: Real-time dashboard with cost per agent, tier distribution, budget burn rate

**Agent-Specific Logging**:

**Coder Agent Logs**:
```json
{
  "agent": "coder",
  "task": "Refactor auth to JWT",
  "codebase": "/home/user/my-app",
  "execution_id": "exec_abc123",
  "trace_id": "trace_xyz789",
  "phases": [
    {
      "phase": "planning",
      "tier": 3,
      "model": "architect",
      "cost": 0.15,
      "tokens": 1250,
      "duration_ms": 3200,
      "output": "Plan with 7 subtasks"
    },
    {
      "phase": "execution",
      "subtasks": [
        {
          "task": "Find auth files",
          "tier": 0,
          "cost": 0,
          "files_found": ["src/auth.js", "middleware/jwt.js"]
        },
        {
          "task": "Generate JWT utils",
          "tier": 1,
          "cost": 0.035,
          "file_written": "src/utils/jwt.js",
          "lines_added": 45
        }
      ]
    },
    {
      "phase": "review",
      "tier": 3,
      "cost": 0.15,
      "validation": "passed",
      "suggestions": ["Add token expiry check"]
    },
    {
      "phase": "git_commit",
      "branch": "ai-agent/jwt-refactor",
      "commit_hash": "abc123def",
      "files_modified": 3
    }
  ],
  "total_cost": 0.335,
  "total_duration_ms": 15400,
  "status": "completed"
}
```

**Web Agent Logs**:
```json
{
  "agent": "web",
  "task": "Research competitor pricing",
  "target_url": "https://competitor.com/pricing",
  "execution_id": "exec_def456",
  "trace_id": "trace_uvw456",
  "phases": [
    {
      "phase": "planning",
      "tier": 3,
      "cost": 0.12,
      "plan": "Navigate, extract table, analyze"
    },
    {
      "phase": "web_automation",
      "browser_session_id": "browser_789",
      "actions": [
        {
          "action": "navigate",
          "url": "https://competitor.com/pricing",
          "duration_ms": 2100,
          "screenshot": "screenshots/pricing_page.png"
        },
        {
          "action": "extract_content",
          "method": "firecrawl",
          "content_length": 4500,
          "structured": true
        },
        {
          "action": "vision_analysis",
          "tier": 2,
          "cost": 0,
          "extracted": "3 pricing tiers identified"
        }
      ]
    },
    {
      "phase": "report_generation",
      "tier": 1,
      "cost": 0.05,
      "report_path": "research/competitor-pricing.md"
    }
  ],
  "total_cost": 0.17,
  "total_duration_ms": 8300,
  "status": "completed"
}
```

**Observability Stack**:
- **n8n Execution Logs**: All workflow I/O (30-day retention)
- **LangSmith/Langfuse**: All LLM prompts/responses (90-day retention)
- **OpenTelemetry + Jaeger**: Distributed traces (7-day retention)
- **Helicone**: Cost tracking, cache analytics (30-day retention)
- **MCPcat**: Tool call tracking (web automation actions)

**Cost Analytics Dashboard**:
- Cost per agent type (coder vs web)
- Cost per tier (0-4)
- Budget pool balances and burn rate
- Tier distribution (% queries per tier)
- Architect/executor cost breakdown
- Cache hit rate and savings

**Validation**:
- âœ… Can I see the full execution flow for any agent task?
- âœ… Can I calculate exact cost per agent invocation?
- âœ… Can I trace a request through all tiers and services?
- âœ… Does dashboard show real-time budget pool status?

---

### VI. Intelligent Routing

**Requirement**: Query/task complexity MUST determine tier selection automatically.

**Rationale**: Not all tasks need expensive Tier 3 models. Intelligent routing saves 60-70% cost while maintaining quality.

**5-Tier System**:

| Tier | Models | Cost | Latency | Use Cases |
|------|--------|------|---------|-----------|
| **0** | Ollama 3B-13B | $0 | <500ms | Classification, intent detection, simple code queries |
| **1** | Fireworks, Together | $0.20-0.80/M | 1-2s | Code generation, web parsing, standard tasks |
| **2** | Ollama 70B+Vision | $0 (VPS) | 2-5s | Screenshot analysis, image understanding |
| **3** | Claude, Gemini | $3-15/M | 3-8s | Planning, review, complex reasoning |
| **4** | RunPod, Salad GPU | $0.69-2/hr | 5-10s | Batch codebase indexing, bulk web scraping |

**Routing Logic**:

**Coder Agent**:
```javascript
function routeCoderTask(task, codebase) {
  // Tier 0: Simple code queries
  if (isSimpleQuery(task)) {
    // "What does this function do?"
    // "Find all API endpoints"
    return { tier: 0, model: 'fast_filter' };
  }

  // Tier 3: Planning phase (Architect)
  if (task.phase === 'planning') {
    return { tier: 3, model: 'architect' };
  }

  // Tier 1: Execution phase (Executor)
  if (task.phase === 'execution' && task.complexity < 0.7) {
    // "Generate utility function"
    // "Add logging statements"
    return { tier: 1, model: 'executor' };
  }

  // Tier 3: Complex execution or review
  if (task.phase === 'execution' && task.complexity >= 0.7) {
    // "Refactor to use dependency injection"
    return { tier: 3, model: 'architect' };
  }

  // Tier 3: Review phase (Reviewer)
  if (task.phase === 'review') {
    return { tier: 3, model: 'architect' };
  }

  // Tier 4: Batch indexing
  if (codebase.fileCount > 50 && task.type === 'indexing') {
    return { tier: 4, model: 'batch_gpu' };
  }

  // Default: Tier 1
  return { tier: 1, model: 'executor' };
}
```

**Web Agent**:
```javascript
function routeWebTask(task, content) {
  // Tier 0: Simple classification
  if (task.type === 'classify_content') {
    // "Is this a pricing page?"
    return { tier: 0, model: 'fast_filter' };
  }

  // Tier 3: Planning
  if (task.phase === 'planning') {
    return { tier: 3, model: 'architect' };
  }

  // Tier 2: Screenshot analysis
  if (content.hasScreenshot && !content.hasText) {
    return { tier: 2, model: 'vision' };
  }

  // Tier 1: Text extraction and parsing
  if (task.type === 'extract_data') {
    return { tier: 1, model: 'executor' };
  }

  // Tier 1: Report generation
  if (task.phase === 'report') {
    return { tier: 1, model: 'executor' };
  }

  // Tier 4: Batch scraping
  if (task.pageCount > 50) {
    return { tier: 4, model: 'batch_gpu' };
  }

  // Default: Tier 1
  return { tier: 1, model: 'executor' };
}
```

**RouteLLM Integration**:
- Complexity scoring for ambiguous tasks
- Logged routing decisions for audit
- Manual override via workflow parameter

**Validation**:
- âœ… Are 40%+ of tasks routed to Tier 0?
- âœ… Is planning always Tier 3?
- âœ… Is execution mostly Tier 1?
- âœ… Does batch detection work (>50 operations â†’ Tier 4)?

---

### VII. Tool Integration Standards

**Requirement**: External tools MUST follow structured integration patterns with proper error handling.

**Rationale**: Agents interact with many external tools (git, Playwright, Firecrawl). Standardized integration prevents fragile workflows.

**Integration Patterns**:

**1. File System Operations** (Coder Agent)
```javascript
// n8n Code Node: Read File
const fs = require('fs');
const path = $json.filePath;

try {
  if (!fs.existsSync(path)) {
    throw new Error(`File not found: ${path}`);
  }

  const content = fs.readFileSync(path, 'utf-8');
  return [{
    filePath: path,
    content: content,
    lines: content.split('\n').length,
    size: Buffer.byteLength(content, 'utf-8')
  }];
} catch (error) {
  return [{
    error: true,
    message: error.message,
    filePath: path
  }];
}
```

**2. Git Operations** (Coder Agent)
```javascript
// n8n Code Node: Git Commit
const { execSync } = require('child_process');
const codebasePath = $json.codebasePath;
const message = $json.commitMessage;
const files = $json.modifiedFiles;

try {
  // Change to codebase directory
  process.chdir(codebasePath);

  // Add files
  files.forEach(file => {
    execSync(`git add ${file}`);
  });

  // Commit
  const commitHash = execSync(`git commit -m "${message}" --author="AI Agent <agent@n8n>"`).toString().trim();

  // Push (optional)
  if ($json.autoPush) {
    const branch = execSync('git branch --show-current').toString().trim();
    execSync(`git push origin ${branch}`);
  }

  return [{
    success: true,
    commitHash: commitHash,
    branch: execSync('git branch --show-current').toString().trim(),
    filesCommitted: files.length
  }];
} catch (error) {
  return [{
    error: true,
    message: error.message,
    stderr: error.stderr?.toString()
  }];
}
```

**3. Browser Automation** (Web Agent)
```javascript
// n8n HTTP Request Node: Call Playwright Service
// URL: http://playwright-service:3000/navigate
// Method: POST
// Body:
{
  "action": "navigate",
  "url": "https://example.com",
  "screenshot": true,
  "waitFor": "networkidle"
}

// Response:
{
  "success": true,
  "url": "https://example.com",
  "screenshot": "/screenshots/page_12345.png",
  "html": "<html>...",
  "duration_ms": 2100
}
```

**4. Web Scraping** (Web Agent)
```javascript
// n8n HTTP Request Node: Call Firecrawl
// URL: https://api.firecrawl.dev/v0/scrape
// Method: POST
// Headers: Authorization: Bearer ${FIRECRAWL_API_KEY}
// Body:
{
  "url": "https://example.com/pricing",
  "formats": ["markdown", "structured"],
  "onlyMainContent": true
}

// Response:
{
  "success": true,
  "markdown": "# Pricing\n\n| Plan | Price |\n|------|-------|\n...",
  "structured": {
    "pricing_tiers": [
      { "name": "Basic", "price": "$10/mo" },
      { "name": "Pro", "price": "$50/mo" }
    ]
  }
}
```

**Tool Registry**:

| Tool | Use Case | Agent | Integration Method |
|------|----------|-------|-------------------|
| **File I/O** | Read/write code | Coder | n8n Code Node (fs module) |
| **Git** | Commit automation | Coder | n8n Code Node (child_process) |
| **Playwright** | Browser automation | Web | HTTP Request â†’ Playwright service |
| **Firecrawl** | Web scraping | Web | HTTP Request â†’ Firecrawl API |
| **Tree-sitter** | AST parsing | Coder | HTTP Request â†’ Parser service |
| **Qdrant** | Vector search | Both | HTTP Request â†’ Qdrant API |
| **LiteLLM** | LLM calls | Both | HTTP Request â†’ LiteLLM API |

**Error Handling Standard**:
- ALL tool calls MUST have try/catch
- ALL tool calls MUST have timeout (30s default)
- ALL errors MUST return structured error object:
  ```json
  {
    "error": true,
    "tool": "playwright",
    "message": "Navigation timeout",
    "context": { "url": "...", "timeout_ms": 30000 }
  }
  ```

**Validation**:
- âœ… Do all file operations validate paths before reading?
- âœ… Do all git operations check for repo existence?
- âœ… Do all browser operations have timeout and cleanup?
- âœ… Do all tool errors return structured error objects?

---

### VIII. Cost-Optimized Provider Selection

**Requirement**: Provider orchestration MUST consider both model capability AND pricing model economics.

**Rationale**: Different providers have different pricing models (hourly vs per-token). Optimal provider depends on workload volume.

**Pricing Models**:

| Provider Category | Pricing | Best For | Providers |
|-------------------|---------|----------|-----------|
| **Local (Free)** | $0 | All simple tasks, vision | Ollama (Tier 0/2) |
| **Per-Token** | $0.20-0.80/M | Bursty traffic, <50 ops | Fireworks, Together (Tier 1) |
| **Premium APIs** | $3-15/M | Complex reasoning only | Claude, Gemini (Tier 3) |
| **Hourly VRAM** | $0.69-2/hr | Batch ops >50, sustained load | RunPod, Salad (Tier 4) |

**Dynamic Provider Selection**:

```javascript
function selectProvider(task, batchSize) {
  // Local first (free)
  if (task.complexity <= 0.2 || task.tier === 0) {
    return { provider: 'ollama', model: 'llama3.2:3b', cost: 0 };
  }

  // Vision tasks â†’ local multimodal
  if (task.hasImages && task.tier === 2) {
    return { provider: 'ollama', model: 'llama3.2-vision:70b', cost: 0 };
  }

  // Batch detection for Tier 4
  if (batchSize >= 50) {
    const tier1Cost = batchSize * 0.0003;  // Per-token cost
    const tier4Cost = (batchSize * 5 / 3600) * 0.69;  // Hourly cost

    if (tier4Cost < tier1Cost * 0.7) {  // 30% savings threshold
      return { provider: 'runpod', model: 'llama-405b', cost: tier4Cost, batch: true };
    }
  }

  // Standard execution â†’ per-token
  if (task.tier === 1) {
    return { provider: 'fireworks', model: 'llama-8b', cost: 0.0003 };
  }

  // Planning/review â†’ premium
  if (task.tier === 3) {
    return { provider: 'anthropic', model: 'claude-3.5-sonnet', cost: 0.012 };
  }

  // Fallback
  return { provider: 'fireworks', model: 'llama-8b', cost: 0.0003 };
}
```

**Budget Pool Management**:
- `hourly_vram`: Tier 4 GPU rental ($100/month)
- `per_token`: Tier 1 providers ($50/month)
- `premium`: Tier 3 planning/review ($50/month)
- `local_vps`: Tier 0/2 infrastructure ($75/month)

**Auto-Shutdown**:
- Tier 4 instances auto-shutdown after 30 min idle
- Prevents wasting hourly charges
- n8n scheduled workflow checks instance uptime every 15 min

**Validation**:
- âœ… Does system calculate per-token vs hourly cost before routing?
- âœ… Do Tier 4 instances shutdown automatically when idle?
- âœ… Are budget pools tracked separately?

---

### IX. Architect/Executor Pattern

**Requirement**: Multi-step tasks MUST use tiered agent roles for cost optimization.

**Rationale**: Tier 3 models excel at planning but are expensive. Tier 0/1 models can execute simple subtasks cheaply. Separating roles achieves 50%+ cost savings.

**Pattern**:
1. **Architect** (Tier 3): Analyze task â†’ Create detailed plan with subtasks
2. **Executor** (Tier 0/1): Execute each subtask independently
3. **Reviewer** (Tier 3): Validate results â†’ Provide feedback

**Economics**:
```
Traditional (all Tier 3):
- Planning: $0.15
- Execute 10 steps Ã— $0.15 = $1.50
- Review: $0.15
- Total: $1.80

Architect/Executor:
- Architect (Tier 3): $0.15
- Execute 10 steps Ã— $0.035 (Tier 1) = $0.35
- Reviewer (Tier 3): $0.15
- Total: $0.65
- Savings: 64%
```

**Coder Agent Implementation**:
```javascript
// Phase 1: Architect (Tier 3)
const plan = await callLLM({
  model: 'architect',
  prompt: `Task: ${userTask}\nCodebase: ${codebaseStructure}\n\nCreate a detailed plan with 10-15 executable subtasks.`
});

// Phase 2: Execute (Tier 0/1)
const results = [];
for (const subtask of plan.subtasks) {
  const complexity = analyzeComplexity(subtask);
  const tier = complexity < 0.3 ? 0 : 1;

  const result = await callLLM({
    model: tier === 0 ? 'fast_filter' : 'executor',
    prompt: subtask.description
  });

  results.push(result);
}

// Phase 3: Review (Tier 3)
const review = await callLLM({
  model: 'architect',
  prompt: `Review the following implementation:\n${JSON.stringify(results)}\n\nValidate quality and suggest improvements.`
});
```

**Web Agent Implementation**:
```javascript
// Phase 1: Architect (Tier 3)
const plan = await callLLM({
  model: 'architect',
  prompt: `Task: ${webTask}\nTarget: ${targetURL}\n\nCreate a step-by-step web automation plan.`
});

// Phase 2: Execute (Tier 1/2)
const results = [];
for (const step of plan.steps) {
  if (step.requiresVision) {
    // Use Tier 2 for screenshot analysis
    const result = await callLLM({
      model: 'vision',
      prompt: step.description,
      image: step.screenshot
    });
  } else {
    // Use Tier 1 for text processing
    const result = await callLLM({
      model: 'executor',
      prompt: step.description
    });
  }
  results.push(result);
}

// Phase 3: Generate Report (Tier 1)
const report = await callLLM({
  model: 'executor',
  prompt: `Generate a summary report from these results:\n${JSON.stringify(results)}`
});
```

**When to Use**:
- âœ… Multi-step coding tasks (refactoring, feature implementation)
- âœ… Multi-page web scraping (research, competitor analysis)
- âœ… Batch operations (process >10 files/pages)
- âŒ Single-step tasks (simple queries, one file modification)

**Validation**:
- âœ… Are multi-step tasks using architect/executor?
- âœ… Is cost breakdown logged per role?
- âœ… Are savings vs all-Tier-3 measured?

---

### X. RAG Context Optimization (Anti-Hallucination)

**Requirement**: Optimize RAG retrieval for premium model context windows and prevent hallucination through precise context management.

**Rationale**:
- **Claude narrow context**: Claude 3.5 Sonnet limited to ~200k tokens (expensive at $3/M input)
- **Gemini wide context**: Gemini 1.5 Pro supports 2M tokens (cheaper at $1.25/M input)
- **Hallucination risk**: Large, unfocused context increases hallucination probability
- **API cost danger**: Premium model API usage scales with context size. Subscriptions are affordable ($30/mo), but API usage can explode ($100s/mo).
- **Precision over volume**: Smaller, highly relevant context > large, noisy context

**Core Strategy**:
1. **Use consolidated RAG libraries**: Leverage battle-tested repos (LlamaIndex, LangChain), not raw implementations
2. **Context compression**: Tier 0 model summarizes/filters context before passing to Tier 3
3. **Hybrid retrieval**: Combine vector search + keyword search + reranking
4. **Adaptive chunking**: Code-aware chunking (function/class boundaries), not fixed 512-token chunks
5. **Google Vertex AI RAG**: Add option for managed RAG (cheap, optimized for Gemini)

**Requirements**:

**Coder Agent RAG**:
- **Chunking strategy**: Parse AST boundaries (functions, classes, not arbitrary splits)
- **Embedding model**: Local open-source (e.g., all-MiniLM-L6-v2, 384 dim) for cost control
- **Retrieval**: Top-K vector search (K=5-10), rerank with Tier 0 model
- **Context budget**: <8k tokens for Claude, <32k for Gemini (never use full context window)
- **Compression**: If retrieval >8k tokens, use Tier 0 to extract key snippets
- **Collection per codebase**: `codebase_{name}` with metadata (file, function, class, imports)
- **Google Vertex AI RAG option**: Use Vertex AI Agent Builder for Gemini-optimized retrieval

**Web Agent RAG**:
- **Chunking strategy**: Semantic blocks (headers, paragraphs, tables)
- **Embedding model**: Same as Coder Agent (consistency)
- **Retrieval**: Top-K vector search (K=3-5), prioritize recent content
- **Context budget**: <5k tokens for report generation (avoid bloat)
- **Cache web content**: Store in Qdrant for 7 days (avoid re-scraping)
- **Screenshot metadata**: Store visual analysis results, not raw images

**Context Compression Pattern**:
```javascript
// Before passing context to Tier 3 architect
async function compressContext(rawContext, task) {
  if (rawContext.length < 8000) {
    return rawContext;  // No compression needed
  }

  // Use Tier 0 to compress
  const compressed = await callLLM({
    tier: 0,
    model: 'fast_filter',
    prompt: `Extract ONLY the code/content relevant to: "${task}"\n\nContext:\n${rawContext}\n\nReturn compressed version (max 7000 tokens).`
  });

  // Log compression ratio
  logMetric('context_compression_ratio', rawContext.length / compressed.length);

  return compressed;
}

// Use compressed context with architect
const plan = await callLLM({
  tier: 3,
  model: 'architect',
  prompt: `Task: ${task}\n\nRelevant context:\n${compressedContext}\n\nCreate plan.`
});
```

**RAG Library Integration**:
- **Primary**: LlamaIndex (Python service, HTTP API)
- **Fallback**: LangChain if LlamaIndex unavailable
- **Managed option**: Google Vertex AI RAG (API, pay-per-query)
- **Storage**: Qdrant vector database (self-hosted)

**Vertex AI RAG Integration** (Optional):
```javascript
// For Gemini users: Use Google's managed RAG
const ragResult = await fetch('https://discoveryengine.googleapis.com/v1/projects/PROJECT/locations/global/collections/default_collection/dataStores/DATASTORE_ID/servingConfigs/default_search:search', {
  method: 'POST',
  headers: {
    'Authorization': `Bearer ${GOOGLE_API_KEY}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    query: task,
    pageSize: 5,
    queryExpansionSpec: { condition: 'AUTO' },
    spellCorrectionSpec: { mode: 'AUTO' }
  })
});

// Cost: $0.002 per 1000 queries (very cheap)
// Benefit: Optimized for Gemini's 2M context window
```

**Validation**:
- âœ… Is retrieved context <8k tokens for Claude calls?
- âœ… Is context compression active for large retrievals?
- âœ… Are embeddings generated by local models (not OpenAI API)?
- âœ… Is hallucination rate measured (via human eval or Tier 3 validator)?
- âœ… Does system support Google Vertex AI RAG option?

---

### XI. Privacy Mode & Data Sovereignty

**Requirement**: Provide privacy-first mode that keeps ALL data on local/VPS infrastructure. No external API calls.

**Rationale**:
- **Data sensitivity**: Some codebases/tasks contain proprietary or sensitive information
- **Regulatory compliance**: GDPR, HIPAA, SOC2 may prohibit sending data to external APIs
- **Cost predictability**: Local-only mode has fixed monthly cost (VPS), no variable API charges
- **Future home deployment**: Privacy mode works on home hardware (powerful local GPU), premium APIs never will

**Privacy Mode Behavior**:

**Enabled** (Privacy Mode ON):
- âœ… Tier 0: Ollama local models (allowed)
- âœ… Tier 2: Ollama Vision local models (allowed)
- âŒ Tier 1: Fireworks/Together APIs (BLOCKED)
- âŒ Tier 3: Claude/Gemini APIs (BLOCKED)
- âŒ Tier 4: RunPod/Salad cloud GPUs (BLOCKED - but configurable if self-hosted VPS)
- âœ… RAG: Local Qdrant (allowed)
- âœ… Browser: Local Playwright service (allowed)

**Disabled** (Privacy Mode OFF):
- âœ… All tiers enabled (Tier 0-4)
- âœ… Premium APIs for planning/review (Tier 3)
- âœ… Cloud GPU rental for batch operations (Tier 4)

**Implementation**:
```javascript
// Privacy mode check in routing workflow
function routeWithPrivacy(task, privacyMode) {
  const baseRouting = routeTask(task);  // Normal tier selection

  if (privacyMode && baseRouting.tier >= 1 && baseRouting.tier !== 2) {
    // Privacy mode: Fallback external tiers to local equivalents
    if (baseRouting.tier === 1) {
      // Tier 1 â†’ Tier 0 with larger local model
      return { tier: 0, model: 'ollama/llama3.2:13b', reason: 'Privacy mode: Using local 13B instead of API' };
    }
    if (baseRouting.tier === 3) {
      // Tier 3 â†’ Tier 0 with largest local model
      return { tier: 0, model: 'ollama/llama3.1:70b', reason: 'Privacy mode: Using local 70B instead of Claude/Gemini' };
    }
    if (baseRouting.tier === 4) {
      // Tier 4 â†’ Reject or use local batch processing
      throw new Error('Privacy mode: Batch GPU operations not available. Use local processing or disable privacy mode.');
    }
  }

  return baseRouting;
}
```

**UI Indication**:
- Web chat MUST show privacy mode status prominently (toggle in header)
- Privacy mode ON: Green lock icon + "All data stays local"
- Privacy mode OFF: Orange shield icon + "Using external APIs"
- Cost display: Show "Fixed $75/mo (local)" vs "Variable API cost"

**Quality Trade-offs** (User-Acknowledged):
- Privacy mode may reduce quality for complex tasks (no Tier 3 access)
- Planning tasks will use Tier 0 largest model (70B) instead of Tier 3 (Claude/Gemini)
- User explicitly accepts quality trade-off for privacy guarantee

**Tier 4 Configurability**:
- If user self-hosts GPU on VPS (not RunPod/Salad cloud), Tier 4 can remain enabled in privacy mode
- Config flag: `privacy_mode_allows_self_hosted_tier4: true`

**Validation**:
- âœ… Does privacy mode block all external API calls (Tier 1, 3, 4)?
- âœ… Does UI clearly indicate privacy mode status?
- âœ… Are all privacy mode tasks routed to Tier 0/2 only?
- âœ… Is user warned about quality trade-offs before enabling?

---

### XII. Agent Specialization

**Requirement**: Each agent type MUST have specialized capabilities for its domain while sharing the same cost optimization framework.

**Rationale**: Coder and Web agents have fundamentally different tool requirements. Specialization improves quality while maintaining architectural consistency.

**Coder Agent Specialization**:

**Capabilities**:
- âœ… Read/write files in codebase
- âœ… Parse code structure (AST via tree-sitter)
- âœ… Search codebase via RAG (vector search)
- âœ… Execute git operations (branch, commit, push)
- âœ… Run linters/formatters (optional)
- âœ… Generate code (functions, classes, tests)

**Tools**:
- File System: n8n Code Node (fs module)
- Git: n8n Code Node (child_process)
- AST Parser: HTTP Request â†’ tree-sitter service
- RAG: HTTP Request â†’ Qdrant
- Linters: HTTP Request â†’ eslint/pylint service (optional)

**Constraints**:
- MUST validate codebase path exists before operations
- MUST create git branch before modifications
- MUST commit changes after modifications
- MUST never delete files without explicit user confirmation
- MUST never modify files outside specified codebase path

**Example Tasks**:
- "Refactor authentication to use JWT tokens"
- "Add logging to all API endpoints"
- "Find and fix all ESLint errors"
- "Write unit tests for user service"
- "Extract this function into a reusable utility"

---

**Web Agent Specialization**:

**Capabilities**:
- âœ… Navigate websites (Playwright)
- âœ… Extract structured data (Firecrawl)
- âœ… Analyze screenshots (Vision model)
- âœ… Fill forms and click buttons (Playwright)
- âœ… Handle authentication (cookies, sessions)
- âœ… Respect rate limits and robots.txt

**Tools**:
- Browser Automation: HTTP Request â†’ Playwright service (self-hosted)
- Web Scraping: HTTP Request â†’ Firecrawl API (optional, can use Playwright only)
- Vision Analysis: HTTP Request â†’ LiteLLM (Tier 2 - local Ollama Vision)
- Content Storage: HTTP Request â†’ Qdrant (for future RAG)

**Privacy & Performance Requirements**:

**Problem**: Each browser has its own automation quirks. Per-browser implementations have terrible performance and privacy (tracking, fingerprinting, resource leaks).

**Solution**: Unified Playwright-based architecture with privacy-first design:

1. **Single Browser Engine**: Chromium only (via Playwright)
   - Consistent behavior across all tasks
   - Lighter than multi-browser support
   - Better performance (shared binary cache)

2. **Privacy Hardening**:
   - Disable telemetry and tracking: `--disable-sync --disable-background-networking`
   - Block ads and trackers: Use uBlock Origin filters programmatically
   - Randomize fingerprint: Rotate user agents, viewport sizes, timezones
   - No persistent profile: Fresh context per session (no cookies/cache leakage)
   - DNS-over-HTTPS: Prevent ISP tracking
   - Proxy support: Optional SOCKS5/HTTP proxy for IP rotation

3. **Performance Optimization**:
   - Headless by default: 40-50% faster than headed mode
   - Resource blocking: Block images/fonts/media when not needed (`--blink-settings=imagesEnabled=false`)
   - Connection pooling: Reuse browser instances across tasks (session management)
   - Parallel execution: Up to 5 concurrent browser contexts
   - Memory limits: Auto-restart browser after 100 pages or 2GB RAM

4. **Self-Hosted Playwright Service**:
   - HTTP API on port 3000 (internal VPS network only)
   - Stateless endpoints: No browser state persisted between API calls
   - Session management: Create/reuse/destroy browser contexts via session IDs
   - Auto-cleanup: Close abandoned sessions after 5 min idle
   - Health monitoring: Expose /health endpoint for n8n monitoring

**Enhanced Playwright Service Architecture**:
```javascript
// Hardened browser launch config
const browser = await chromium.launch({
  headless: true,
  args: [
    '--no-sandbox',
    '--disable-setuid-sandbox',
    '--disable-dev-shm-usage',  // Prevent /dev/shm crashes
    '--disable-gpu',
    '--disable-sync',
    '--disable-background-networking',
    '--disable-default-apps',
    '--disable-extensions',
    '--disable-translate',
    '--metrics-recording-only',
    '--mute-audio',
    '--no-first-run',
    '--safebrowsing-disable-auto-update',
    '--blink-settings=imagesEnabled=false'  // Conditional: Disable if task doesn't need images
  ]
});

// Privacy-hardened context
const context = await browser.newContext({
  viewport: randomizeViewport(),  // Randomize to avoid fingerprinting
  userAgent: randomizeUserAgent(),
  locale: 'en-US',
  timezoneId: 'America/New_York',
  permissions: [],  // Deny all permissions (geolocation, notifications, etc.)
  ignoreHTTPSErrors: false,  // Enforce HTTPS
  bypassCSP: false,  // Respect Content Security Policy
  extraHTTPHeaders: {
    'DNT': '1',  // Do Not Track
    'Sec-GPC': '1'  // Global Privacy Control
  }
});

// Resource optimization
await context.route('**/*', (route) => {
  const resourceType = route.request().resourceType();
  // Block ads, trackers, analytics
  if (['image', 'media', 'font'].includes(resourceType) && !task.requiresVisuals) {
    route.abort();
  } else {
    route.continue();
  }
});
```

**Constraints**:
- MUST run browsers in headless mode (override only for debugging)
- MUST respect robots.txt (check before scraping)
- MUST add delays between requests (rate limiting: 1-3s random delay)
- MUST close browser sessions on completion (mandatory cleanup)
- MUST save screenshots on errors for debugging
- MUST never log credentials or sensitive data
- MUST use privacy-hardened browser config (no tracking, fingerprint randomization)
- MUST block unnecessary resources (images/fonts) when not needed for task
- MUST auto-restart browser after 100 pages or 2GB RAM (prevent memory leaks)
- MUST support proxy configuration for IP rotation (optional)

**Example Tasks**:
- "Research competitor pricing from their website"
- "Monitor this page for price changes daily"
- "Extract all product reviews from Amazon"
- "Fill out this contact form with test data"
- "Login to dashboard and download monthly reports"

---

**Shared Framework** (Both Agents):

Both agents share the same:
- âœ… 5-tier cost optimization
- âœ… Pre-budget checks
- âœ… Architect/executor pattern
- âœ… Observability (logging, tracing, cost tracking)
- âœ… Error handling (rollback, cleanup)
- âœ… LiteLLM integration

**Agent Selection Logic**:
```javascript
function selectAgent(userInput) {
  // Detect codebase path
  const hasCodebasePath = /\/[a-z0-9_\-\/]+/i.test(userInput);

  // Detect code-related keywords
  const codeKeywords = ['refactor', 'function', 'class', 'file', 'code', 'git', 'commit', 'test'];
  const hasCodeKeyword = codeKeywords.some(kw => userInput.toLowerCase().includes(kw));

  // Detect web-related keywords
  const webKeywords = ['website', 'scrape', 'navigate', 'extract', 'url', 'browser', 'page'];
  const hasWebKeyword = webKeywords.some(kw => userInput.toLowerCase().includes(kw));

  // Detect URL
  const hasURL = /https?:\/\/[^\s]+/.test(userInput);

  // Select agent
  if (hasCodebasePath || hasCodeKeyword) {
    return 'coder';
  } else if (hasURL || hasWebKeyword) {
    return 'web';
  } else {
    // Ambiguous - ask user or use Tier 0 to classify
    return classifyIntent(userInput);
  }
}
```

**Validation**:
- âœ… Does Coder Agent only operate within specified codebase?
- âœ… Does Web Agent always close browser sessions?
- âœ… Can both agents use architect/executor pattern?
- âœ… Are agent-specific tools properly isolated?

---

### XIII. Web Chat UI/UX Requirements

**Requirement**: Web chat interface MUST provide full transparency on costs, privacy mode, and agent selection. Cost tracking MUST be real-time and granular.

**Rationale**:
- **Cost transparency**: Users need to understand how much each query costs BEFORE sending
- **Privacy awareness**: Users must explicitly choose between privacy (local-only) and quality (premium APIs)
- **Agent clarity**: Users should understand which agent (Coder/Web) and which mode (standard/multimodal) they're using
- **Budget control**: Real-time cost dashboard prevents budget overruns

**UI Components**:

**1. Header Controls**:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ [Privacy: ON ğŸ”’]  [Agent: Coder ğŸ’»]  [Multimodal: OFF ğŸ‘ï¸]  â”‚
â”‚                                                               â”‚
â”‚ Budget: $6.23 / $50.00  [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘] 12%             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Privacy Toggle**:
- **ON (Green Lock ğŸ”’)**: "All data stays local" - Tier 0/2 only
- **OFF (Orange Shield ğŸ›¡ï¸)**: "Using external APIs" - All tiers enabled
- Click to toggle, shows confirmation dialog explaining trade-offs

**Agent Selector**:
- **Coder ğŸ’»**: For code tasks (requires codebase path)
- **Web ğŸŒ**: For web tasks (requires URL)
- Auto-detect based on input (show suggestion: "Detected code task - switch to Coder?")

**Multimodal Toggle**:
- **OFF**: Web Agent uses text-only extraction (Firecrawl + Tier 1)
- **ON**: Web Agent uses vision analysis (Tier 2 local vision)
- Only visible when Web Agent selected
- Auto-enable if task requires screenshots ("analyze this page layout")

**2. Pre-Prompt Cost Estimate**:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Your prompt (312 chars):                                     â”‚
â”‚ "Refactor the auth module to use JWT tokens"                â”‚
â”‚                                                               â”‚
â”‚ Estimated cost: $0.08 - $0.15                                â”‚
â”‚ Breakdown:                                                    â”‚
â”‚   â€¢ Planning (Tier 3): ~$0.06                                â”‚
â”‚   â€¢ Execution (Tier 1): ~$0.04 (8 subtasks)                 â”‚
â”‚   â€¢ Review (Tier 3): ~$0.05                                  â”‚
â”‚                                                               â”‚
â”‚ [Privacy: OFF] Switch to Privacy mode: ~$0 (local Tier 0)   â”‚
â”‚                                                               â”‚
â”‚ [Send] [Cancel]                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Pre-Prompt Estimate Logic**:
- Analyze prompt complexity (length, keywords, task type)
- Estimate tier routing (architect/executor pattern phases)
- Show cost range (min/max based on routing uncertainty)
- Show privacy mode cost comparison if privacy OFF
- Update in real-time as user types (debounced)

**3. Real-Time Execution Cost Tracking**:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Task: Refactor auth module                  Status: Running  â”‚
â”‚                                                               â”‚
â”‚ Phase 1: Planning âœ“                         Cost: $0.06      â”‚
â”‚   â€¢ Tier 3 (Claude 3.5) - 1,250 tokens                      â”‚
â”‚                                                               â”‚
â”‚ Phase 2: Execution (5/8 subtasks) â³         Cost: $0.03      â”‚
â”‚   â€¢ Find auth files (Tier 0) - $0                           â”‚
â”‚   â€¢ Generate JWT utils (Tier 1) - $0.02                     â”‚
â”‚   â€¢ Update middleware (Tier 1) - $0.01                      â”‚
â”‚   â€¢ Testing endpoints... â³                                   â”‚
â”‚                                                               â”‚
â”‚ Total so far: $0.09 / $0.15 est             [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘]    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Real-Time Tracking Features**:
- Phase-by-phase cost breakdown
- Tier used for each step with model name
- Token counts (input + output)
- Progress bar vs estimated cost
- Warning if exceeds estimate by >20%

**4. Post-Execution Cost Summary**:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Task Complete âœ“                            Total: $0.13      â”‚
â”‚                                                               â”‚
â”‚ Cost Breakdown:                                              â”‚
â”‚   â€¢ Planning (Tier 3 - Claude):     $0.06  (1,250 tok)      â”‚
â”‚   â€¢ Execution (Tier 1 - Llama 8B):  $0.04  (3,200 tok)      â”‚
â”‚   â€¢ Review (Tier 3 - Claude):       $0.05  (1,100 tok)      â”‚
â”‚   â€¢ Git operations (Tier 0):        $0     (local)          â”‚
â”‚                                                               â”‚
â”‚ Tokens: 5,550 in + 2,100 out = 7,650 total                  â”‚
â”‚                                                               â”‚
â”‚ Files modified: 3 (auth.js, jwt.js, middleware/auth.js)     â”‚
â”‚ Branch: ai-agent/jwt-refactor                                â”‚
â”‚ Commit: abc123def                                            â”‚
â”‚                                                               â”‚
â”‚ Budget remaining: $49.87 / $50.00  [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘] 0.3% â”‚
â”‚                                                               â”‚
â”‚ [View Files] [View Logs] [Close]                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**5. Cost Analytics Dashboard** (Sidebar/Modal):
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Cost Analytics - November 2025                               â”‚
â”‚                                                               â”‚
â”‚ Total Spent: $6.23 / $50.00                  [â–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘] 12% â”‚
â”‚                                                               â”‚
â”‚ By Tier:                                                     â”‚
â”‚   Tier 0 (Local):      42% tasks  â”‚ $0.00   â”‚ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â”‚
â”‚   Tier 1 (Fireworks):  31% tasks  â”‚ $2.10   â”‚ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘  â”‚
â”‚   Tier 2 (Vision):      5% tasks  â”‚ $0.00   â”‚ â–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘  â”‚
â”‚   Tier 3 (Claude):     20% tasks  â”‚ $4.00   â”‚ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘  â”‚
â”‚   Tier 4 (GPU):         2% tasks  â”‚ $0.13   â”‚ â–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘  â”‚
â”‚                                                               â”‚
â”‚ By Agent:                                                    â”‚
â”‚   Coder Agent:  65% tasks  â”‚ $4.50   â”‚ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘      â”‚
â”‚   Web Agent:    35% tasks  â”‚ $1.73   â”‚ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘      â”‚
â”‚                                                               â”‚
â”‚ Top Cost Savers:                                             â”‚
â”‚   â€¢ Architect/Executor: Saved $12.40 (57%)                   â”‚
â”‚   â€¢ Privacy Mode:       Saved $8.20 (35 tasks local)         â”‚
â”‚   â€¢ Helicone Cache:     Saved $1.50 (cache hit 23%)         â”‚
â”‚                                                               â”‚
â”‚ Burn Rate: $2.08/week  â”‚  Projected: $9.02/month             â”‚
â”‚                                                               â”‚
â”‚ [Export CSV] [Reset Month] [Close]                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Dashboard Features**:
- Real-time budget pool status (hourly_vram, per_token, premium, local_vps)
- Tier distribution (% of tasks per tier)
- Agent distribution (Coder vs Web)
- Cost savers (architect/executor, privacy mode, caching)
- Burn rate and monthly projection
- Export to CSV for accounting

**6. Privacy Mode Confirmation Dialog**:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Enable Privacy Mode?                                         â”‚
â”‚                                                               â”‚
â”‚ Privacy Mode keeps ALL data on local VPS infrastructure.    â”‚
â”‚ No data sent to external APIs (Claude, Gemini, Fireworks).  â”‚
â”‚                                                               â”‚
â”‚ Benefits:                                                    â”‚
â”‚   âœ“ Complete data privacy (GDPR/HIPAA compliant)            â”‚
â”‚   âœ“ Fixed cost ($75/month VPS only)                         â”‚
â”‚   âœ“ No API usage charges                                     â”‚
â”‚   âœ“ Works with home hardware (future)                       â”‚
â”‚                                                               â”‚
â”‚ Trade-offs:                                                  â”‚
â”‚   âš  Complex tasks use Tier 0 (70B local) instead of Claude  â”‚
â”‚   âš  Planning quality may be slightly lower                   â”‚
â”‚   âš  No access to Tier 3 reasoning (Gemini/Claude)           â”‚
â”‚                                                               â”‚
â”‚ Your current task may take longer in Privacy Mode.          â”‚
â”‚                                                               â”‚
â”‚ [ Enable Privacy Mode ]  [ Cancel ]                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**7. Multimodal Mode Info**:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Multimodal Mode                                              â”‚
â”‚                                                               â”‚
â”‚ When enabled, Web Agent will:                                â”‚
â”‚   â€¢ Capture screenshots of visited pages                     â”‚
â”‚   â€¢ Use Tier 2 Vision (Ollama Vision 70B)                   â”‚
â”‚   â€¢ Analyze page layouts, images, charts                     â”‚
â”‚   â€¢ Extract data from visual elements (tables, graphs)       â”‚
â”‚                                                               â”‚
â”‚ Cost: $0 (local Tier 2 on VPS)                               â”‚
â”‚ Performance: ~2-5s per page (vs 1-2s text-only)             â”‚
â”‚                                                               â”‚
â”‚ Auto-enable when task requires visual analysis:             â”‚
â”‚   â€¢ "analyze the layout of..."                               â”‚
â”‚   â€¢ "extract data from this chart..."                        â”‚
â”‚   â€¢ "screenshot this page..."                                â”‚
â”‚                                                               â”‚
â”‚ [Enable] [Cancel]                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Implementation Requirements**:
- Real-time WebSocket updates for cost tracking during execution
- Debounced pre-prompt cost estimation (500ms after user stops typing)
- Persistent settings (privacy mode, agent preference) in browser localStorage
- Mobile-responsive design (cost dashboard collapses to sidebar drawer)
- Accessibility: ARIA labels, keyboard navigation, screen reader support
- Error handling: Show cost even if task fails (show partial costs)

**Flowise Integration**:
- Flowise-based chat UI with custom React components for cost tracking
- n8n workflow webhook returns structured cost breakdown JSON
- Frontend polls n8n webhook for real-time execution updates
- Budget pool balance fetched from Redis via n8n workflow

**Validation**:
- âœ… Can user see estimated cost BEFORE sending prompt?
- âœ… Does privacy toggle clearly explain trade-offs?
- âœ… Is real-time cost tracking accurate (<5% variance)?
- âœ… Does dashboard show tier distribution and savings?
- âœ… Is multimodal mode auto-suggested when appropriate?

---

## Architecture Constraints

### State Management
- Explicit state passing: JSON objects between n8n nodes
- No hidden globals: All state in workflow execution context
- Agent state includes: task, codebase/url, phase, tier, cost, results
- Persistence: Long-running workflows save state to n8n database

### Vector Database Standards (Qdrant)
- **Coder Agent Collections**: One collection per codebase (`codebase_{name}`)
  - Vectors: Code chunk embeddings (768 dimensions)
  - Metadata: file_path, function_name, class_name, line_start, line_end

- **Web Agent Collections**: One collection for web content (`web_content`)
  - Vectors: Web page chunk embeddings (768 dimensions)
  - Metadata: url, page_title, extraction_date, content_type

- Backup: n8n scheduled workflow calls Qdrant snapshot API daily

### LLM Interface & Routing Layer
- **Unified API**: All LLM calls through LiteLLM HTTP wrapper (OpenAI-compatible)
- **Intelligent Routing**: RouteLLM determines tier based on complexity
- **Cost Orchestration**: Pre-budget check validates pool balance before LLM call (MANDATORY)
- **Cost Proxy**: Helicone sits between LiteLLM and providers (caching, logging)
- **Request Flow**: n8n â†’ Pre-Budget â†’ RouteLLM â†’ LiteLLM â†’ Helicone â†’ Provider
- **Configuration**: Model groups, routing thresholds, fallback chains in litellm-config.yaml
- **Override**: Manual tier selection via workflow parameter

### Git Standards (Coder Agent Only)
- **Branch naming**: `ai-agent/{task-id}` (auto-generated)
- **Commit message format**:
  ```
  <type>: <short summary>

  <detailed description>

  - Change 1
  - Change 2

  Co-authored-by: AI Agent <agent@n8n>
  ```
- **Types**: feat, fix, refactor, test, docs, chore
- **Auto-push**: Optional (default: false, user must manually review and push)

### Browser Automation Standards (Web Agent Only)
- **Playwright version**: Latest stable
- **Browser**: Chromium (headless)
- **Timeout**: 30s per action
- **Screenshots**: Saved on every page navigation and on errors
- **Cleanup**: Always close browser in try/finally block

---

## Quality Standards

### Testing Requirements
- **Coder Agent**: Test with sample codebases (10+ files, different languages)
- **Web Agent**: Test with sample websites (public pages, no auth required initially)
- **Cost Validation**: Compare actual cost vs estimated cost (< 10% variance)
- **Tier Routing**: Validate tier selection accuracy (>90% correct tier)
- **Error Handling**: Test rollback on Coder errors, browser cleanup on Web errors

### Performance Benchmarks
- **Response time**: <10s for simple tasks (Tier 0/1), <30s for complex (Tier 3)
- **Codebase indexing**: >100 files/minute
- **Web scraping**: >10 pages/minute
- **Concurrent support**: 5+ simultaneous agent tasks

### Security
- **API keys**: Stored in n8n Credentials (encrypted at rest)
- **Git operations**: Never commit API keys or credentials
- **Web agent**: Never log passwords or session tokens
- **File operations**: Validate paths prevent directory traversal
- **Sandboxing**: Coder Agent cannot access files outside codebase path

---

## Expected Cost Savings (v4.0)

**Baseline (All Tier 3)**:
- 100 agent tasks/month Ã— $0.50/task = $50/month

**v4.0 (Intelligent Routing)**:
- Tier 0 (40%): 40 tasks Ã— $0 = $0
- Tier 1 (35%): 35 tasks Ã— $0.10 = $3.50
- Tier 2 (5%): 5 tasks Ã— $0 = $0
- Tier 3 (18%): 18 tasks Ã— $0.50 = $9.00
- Tier 4 (2%): 2 tasks Ã— $0.30 = $0.60
- **Total: $13.10**

**With Optimizations**:
- Prompt compression: Save $2
- Architect/executor: Save $4
- Helicone cache: Save $1
- **Final: ~$6-8/month (84-88% savings)**

---

## Document Version
**Constitution Version**: 4.0.0
**Last Updated**: 2025-11-18
**Breaking Changes**: Yes - Complete pivot to multi-agent orchestrator
**Migration**: See ARCHITECTURE_v4.0_COMPLETE.md for migration guide
**Status**: Ready for implementation
